<!-- ============ HEAD ============ -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <title>PING-PON</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#00e5ff">

  <!-- ============ CSS は次のブロックに分離 ============ -->
</head>

<!-- ============ CSS ============ -->
<style>
/* ===CSS=== */
body {
  margin: 0;
  background: #111;
  color: #eee;
  text-align: center;
  font-family: "JetBrains Mono", "Source Code Pro", monospace;
}

.screen { display: none; padding: 6px; }
.active { display: block; }

.version { font-size: 14px; color: #aaa; margin: 0 0 6px; }

h1, h2{
  margin: 4px 0 2px;
  line-height: 1.1;
}

/* ==================================================
   タイマー表示
================================================== */
#timer {
  font-size: 30px;
  margin: -4px auto 2px;
  width: 280px;
  font-variant-numeric: slashed-zero;
}
.red { color: #FF4500; }
.blink {
  animation: blink 0.4s steps(1) infinite;
  color: #FF4500;
}
@keyframes blink { 50% { opacity: 0; } }
.zero-blink {
  animation: fadeBlink 1.2s infinite;
  color: #ff3333;
}
@keyframes fadeBlink {
  0%   { opacity: 1; }
  60%  { opacity: 0; }
  100% { opacity: 1; }
}

/* ==================================================
   マップ表示（端末差を吸収しやすい形）
================================================== */
#map {
  width: min(96vw, 420px);
  aspect-ratio: 1 / 1;         /* ★ height固定計算にしない：端末差でズレにくい */
  margin: 6px auto 6px;

  background: #222;
  border: 2px solid #555;
  position: relative;
  overflow: hidden;
}

/* グリッド */
.grid {
  position: absolute;
  inset: 0;
  background-size: 30px 30px;
  background-image:
    linear-gradient(to right, rgba(0,220,255,0.75) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(0,220,255,0.75) 1px, transparent 1px);
  pointer-events: none;
  z-index: 3;
}

/* グリッドラベル */
#gridLabels {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 7;

  color: rgba(0,220,255,0.95);
  font-size: 12px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  text-shadow: 0 0 2px rgba(0,0,0,1), 0 0 8px rgba(0,0,0,0.8);
}
.grid-x, .grid-y { position: absolute; background: none; padding: 0; border-radius: 0; }
.grid-x { transform: translateX(-50%); }
.grid-y { transform: translateY(-50%); }

/* マップ画像：枠にフィットしつつ中央固定（端末差でズレにくい） */
#mapImg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;

  object-fit: contain;          /* ★ここが効く：表示サイズ差の事故が減る */
  object-position: center;

  transform: scale(var(--imgScale, 1));
  transform-origin: center center;

  user-select: none;
  -webkit-user-drag: none;
  pointer-events: none;
  opacity: 0.9;
  z-index: 1;
}

/* 自分の位置ドット */
#meDot{
  position:absolute;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background:#00e5ff;
  border:2px solid rgba(255,255,255,0.85);
  box-shadow: 0 0 0 2px rgba(0,0,0,0.35);
  transform: translate(-50%, -50%);
  pointer-events:none;
  z-index: 5;
  display:none;
}

/* OUT OF FIELD */
#mapWarning{
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;

  font-size: 24px;
  font-weight: 700;
  letter-spacing: 0.16em;

  color: #ff4528;
  text-shadow: none;

  animation: evaFade 1.4s infinite;
  z-index: 8;
  pointer-events: none;
}
@keyframes evaFade {
  0%   { opacity: 0.35; }
  50%  { opacity: 1.0; }
  100% { opacity: 0.35; }
}

/* GPS表示 */
#gps {
  font-size: 14px;
  margin: 4px auto 0;
  color: #8cf;
  width: 260px;
  height: 20px;
  line-height: 20px;

  display: flex;
  align-items: center;
  justify-content: center;

  white-space: nowrap;
  overflow: hidden;
  font-variant-numeric: tabular-nums;
}

/* フィールド一覧 */
#fieldList {
  width: min(92vw, 420px);
  margin: 8px auto 0;
  text-align: left;
  background: #161616;
  border: 1px solid #333;
  border-radius: 10px;
  padding: 8px 10px;
}
#fieldList button{
  display:block;
  width: min(92vw, 320px);
  margin: 6px auto;
  padding: 12px 14px;
  font-size: 18px;
}
#pager{ margin: 8px 0 6px; }
#pager button{ padding: 8px 14px; }
#pageInfo{ display:inline-block; min-width: 80px; }

/* ボタン */
button { font-size: 16px; padding: 8px 14px; margin: 5px; }

.icon-row{
  display:flex;
  gap:10px;
  justify-content:center;
  align-items:center;
  margin: 6px 0 4px;
}
.icon-btn{
  width: 52px;
  height: 52px;
  border-radius: 14px;
  border: 2px solid rgba(0,220,255,0.35);
  background: rgba(255,255,255,0.04);
  color: rgba(0,220,255,0.95);
  display:flex;
  align-items:center;
  justify-content:center;
  -webkit-tap-highlight-color: transparent;
}
.icon-btn:active{ transform: scale(0.97); }
.icon-btn svg{ width: 28px; height: 28px; display:block; fill: currentColor; }

#settings button, #timerSet button{ margin: 4px; }
#timerSet input{ margin: 4px 0 0; }
</style>

<!-- ============ HTML ============ -->
<body>
  <!-- ==================================================
       メイン画面（フィールド選択）
  ================================================== -->
  <div id="main" class="screen active">
    <h1>PING-PON</h1>

    <!--==========================================
    ============⬇︎⬇︎⬇︎⬇︎⬇︎  VERSION  ⬇︎⬇︎⬇︎⬇︎⬇︎=============-->
    <div class="version">★★ Version 2.4.5 ★★</div>
    <!--==========================================-->

    <div id="fieldList">読み込み中…</div>

    <div id="pager">
      <button type="button" onclick="prevPage()">◀</button>
      <span id="pageInfo">- / -</span>
      <button type="button" onclick="nextPage()">▶</button>
    </div>
  </div>

  <!-- ==================================================
       フィールド画面（タイマー＋マップ）
  ================================================== -->
  <div id="field" class="screen">
    <h2 id="fieldTitle">Field</h2>

    <div id="timer">00:00</div>

    <div id="map">
      <div class="grid"></div>
      <div id="gridLabels"></div>
      <img id="mapImg" alt="map">
      <div id="meDot"></div>
      <div id="mapWarning">//OUT OF FIELD//</div>
    </div>

    <div id="gps">--.------:--.------</div>

    <div class="icon-row">
      <button id="btnStartStop" class="icon-btn" type="button" onclick="toggleStart()" aria-label="Start/Stop"></button>

      <button class="icon-btn" type="button" onclick="resetTimer()" aria-label="Reset">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6a6 6 0 0 1-10.24 4.24l-1.42 1.42A8 8 0 0 0 20 13c0-4.42-3.58-8-8-8z"></path>
        </svg>
      </button>

      <button class="icon-btn" type="button" onclick="scan()" aria-label="GPS Scan">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 8a4 4 0 1 0 .001 8.001A4 4 0 0 0 12 8zm8.94 3A8.99 8.99 0 0 0 13 3.06V1h-2v2.06A8.99 8.99 0 0 0 3.06 11H1v2h2.06A8.99 8.99 0 0 0 11 20.94V23h2v-2.06A8.99 8.99 0 0 0 20.94 13H23v-2h-2.06zM12 19a7 7 0 1 1 .001-14.001A7 7 0 0 1 12 19z"></path>
        </svg>
      </button>

      <button class="icon-btn" type="button" onclick="openSettings()" aria-label="Settings">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.1 7.1 0 0 0-1.63-.94l-.36-2.54A.5.5 0 0 0 13.9 1h-3.8a.5.5 0 0 0-.49.42l-.36 2.54c-.58.22-1.12.52-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L2.71 7.48a.5.5 0 0 0 .12.64l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94L2.83 14.52a.5.5 0 0 0-.12.64l1.92 3.32c.13.22.39.31.6.22l2.39-.96c.5.41 1.05.72 1.63.94l.36 2.54c.04.24.25.42.49.42h3.8c.24 0 .45-.18.49-.42l.36-2.54c.58-.22 1.12-.53 1.63-.94l2.39.96c.21.09.47 0 .6-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58zM12 15.5A3.5 3.5 0 1 1 12 8a3.5 3.5 0 0 1 0 7.5z"></path>
        </svg>
      </button>
    </div>
  </div>

  <!-- ==================================================
       設定画面
  ================================================== -->
  <div id="settings" class="screen">
    <h2>Settings</h2>
    <button type="button" onclick="openTimerSet()">タイマーセット</button><br>
    <button type="button" onclick="backToMain()">メイン画面に戻る</button>
  </div>

  <!-- ==================================================
       タイマー設定画面
  ================================================== -->
  <div id="timerSet" class="screen">
    <h2>Timer Set (min)</h2>
    <input id="minuteInput" type="number" min="0" value="0">
    <br><br>
    <button type="button" onclick="setTimer()">決定</button>
    <button type="button" onclick="openSettings()">戻る</button>
  </div>

  <!-- ============ JS は次のブロックに分離 ============ -->
</body>

<!-- ============ JS ============ -->
<script>
/* ===JS=== */

/* ==================================================
  画面切り替え
================================================== */
function show(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}
function backToMain()   { show('main'); }
function openSettings() { show('settings'); }
function openTimerSet() { show('timerSet'); }

/* ==========================================================
   START/STOP アイコン切替
========================================================== */
function setStartStopIcon(isRunning){
  const btn = document.getElementById("btnStartStop");
  if (!btn) return;

  const pauseSvg = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
    </svg>`;
  const playSvg = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M8 5v14l11-7z"></path>
    </svg>`;

  btn.innerHTML = isRunning ? pauseSvg : playSvg;
}

/* ==================================================
  タイマー関連（Date.now基準 + 省電力 + 復元）
================================================== */

// localStorage keys
const TIMER_STORE_KEY = "pingpon_timer_state_v1";

/*
  保存する状態:
  {
    setTimeMs: number,          // 設定分数から作った総時間(ms)
    remainingMs: number,        // 一時停止中の残り(ms)
    running: boolean,
    zeroMode: boolean,
    endTimeMs: number|null      // running=true のときの終了予定 epoch(ms)
  }
*/

let setTimeMs = 0;
let remainingMs = 0;
let running = false;
let zeroMode = false;

let timerInterval = null;
let endTimeMs = null; // Date.now() epoch(ms)

// tickを省電力化（50→200）
const TICK_MS = 200;

function persistTimerState(){
  const state = { setTimeMs, remainingMs, running, zeroMode, endTimeMs: endTimeMs ?? null };
  try{
    localStorage.setItem(TIMER_STORE_KEY, JSON.stringify(state));
  }catch(e){
    console.warn("persistTimerState failed", e);
  }
}

function stopTicking(){
  if(timerInterval){
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

function startTicking(){
  stopTicking();

  timerInterval = setInterval(() => {
    if(!running || endTimeMs == null) return;

    const now = Date.now();
    remainingMs = Math.max(0, endTimeMs - now);

    if(remainingMs === 0){
      running = false;
      zeroMode = true;
      endTimeMs = null;
      setStartStopIcon(false);
      stopTicking();
    }

    updateDisplay(remainingMs);
    persistTimerState();
  }, TICK_MS);
}

function restoreTimerState(){
  const raw = localStorage.getItem(TIMER_STORE_KEY);
  if(!raw) {
    setStartStopIcon(false);
    updateDisplay(0);
    return;
  }

  try{
    const s = JSON.parse(raw);
    if(typeof s !== "object" || s == null) return;

    setTimeMs = Number(s.setTimeMs ?? 0);
    remainingMs = Number(s.remainingMs ?? 0);
    running = !!s.running;
    zeroMode = !!s.zeroMode;
    endTimeMs = (s.endTimeMs == null) ? null : Number(s.endTimeMs);

    // running中なら「今」を基準に残りを再計算
    if(running && endTimeMs != null){
      const now = Date.now();
      remainingMs = Math.max(0, endTimeMs - now);
      if(remainingMs === 0){
        running = false;
        zeroMode = true;
        endTimeMs = null;
      }
    }

    setStartStopIcon(running);
    updateDisplay(remainingMs);

    if(running){
      startTicking();
    }
  }catch(e){
    console.warn("restoreTimerState failed", e);
  }
}

function setTimer() {
  document.activeElement?.blur?.();
  const min = Number(document.getElementById('minuteInput').value);

  setTimeMs = Math.max(0, min * 60 * 1000);
  remainingMs = setTimeMs;

  running = false;
  zeroMode = false;
  endTimeMs = null;

  stopTicking();
  setStartStopIcon(false);
  updateDisplay(remainingMs);

  persistTimerState();
  show('field');
}

function toggleStart() {
  // まだタイマーセットしてない（0）場合はそのまま
  if(setTimeMs <= 0){
    updateDisplay(remainingMs);
    return;
  }

  if(!running){
    // START
    if(remainingMs <= 0){
      remainingMs = setTimeMs;
      zeroMode = false;
    }

    running = true;
    zeroMode = false;

    // Date.now基準で「終了予定時刻」を固定
    endTimeMs = Date.now() + remainingMs;

    setStartStopIcon(true);
    updateDisplay(remainingMs);
    persistTimerState();

    startTicking();

  }else{
    // STOP（一時停止）
    if(endTimeMs != null){
      remainingMs = Math.max(0, endTimeMs - Date.now());
    }
    running = false;
    endTimeMs = null;

    stopTicking();
    setStartStopIcon(false);
    updateDisplay(remainingMs);
    persistTimerState();
  }
}

function resetTimer() {
  running = false;
  zeroMode = false;
  endTimeMs = null;

  stopTicking();
  remainingMs = setTimeMs;

  setStartStopIcon(false);
  updateDisplay(remainingMs);
  persistTimerState();
}

function updateDisplay(ms) {
  const t = document.getElementById("timer");
  t.classList.remove("red", "blink", "zero-blink");

  if (!running && !zeroMode && ms === 0) {
    t.textContent = "00:00";
    return;
  }

  if (zeroMode) {
    t.classList.add("zero-blink");
    t.textContent = "00:00:00";
    return;
  }

  if (ms <= 180000) t.classList.add("red");
  if (ms <= 30000)  t.classList.add("blink");

  const m  = Math.floor(ms / 60000);
  const s  = Math.floor((ms % 60000) / 1000);
  const cs = Math.floor((ms % 1000) / 10);

  t.textContent = (ms > 180000)
    ? `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`
    : `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(cs).padStart(2,'0')}`;
}

/* ==================================================
  フィールドJSON読み込み（ページング版）
================================================== */
let currentField = null;
let H = null;
let lat0 = 0, lon0 = 0, cosLat0 = 1;

const mapEl = document.getElementById("map");
const mapImg = document.getElementById("mapImg");
const meDot  = document.getElementById("meDot");
const gpsEl  = document.getElementById("gps");
const mapWarning = document.getElementById("mapWarning");

let fieldListData = [];
let currentPage = 0;
const FIELDS_PER_PAGE = 6;

/* anchorsを保持（画像基準 inx/iny or 枠基準 nx/ny 互換） */
let anchorNorm = null; // [{inx,iny,nx,ny,x,y,baseW,baseH,lat,lon,label} x4]

async function loadFieldList() {
  try {
    const res = await fetch("fields/fields.json", { cache: "no-store" });
    if (!res.ok) throw new Error("fields.json not found");

    const data = await res.json();
    if (!Array.isArray(data)) throw new Error("fields.json is not array");

    fieldListData = data;
    currentPage = 0;
    renderFieldList();

  } catch (e) {
    console.error(e);
    document.getElementById("fieldList").textContent =
      "フィールド一覧読み込み失敗：fields/fields.json を確認して";
  }
}

function renderFieldList() {
  const list = document.getElementById("fieldList");
  const pageInfo = document.getElementById("pageInfo");
  if (!list || !pageInfo) return;

  list.innerHTML = "";

  const total = fieldListData.length;
  const totalPages = Math.max(1, Math.ceil(total / FIELDS_PER_PAGE));
  const start = currentPage * FIELDS_PER_PAGE;
  const end = Math.min(start + FIELDS_PER_PAGE, total);

  for (let i = start; i < end; i++) {
    const f = fieldListData[i];
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = f.name ?? f.id ?? f.file ?? "field";
    btn.onclick = () => openFieldByFile(f.file);
    list.appendChild(btn);
  }

  pageInfo.textContent = `${currentPage + 1} / ${totalPages}`;
}

function nextPage() {
  const totalPages = Math.max(1, Math.ceil(fieldListData.length / FIELDS_PER_PAGE));
  if (currentPage < totalPages - 1) { currentPage++; renderFieldList(); }
}
function prevPage() {
  if (currentPage > 0) { currentPage--; renderFieldList(); }
}

function getMapSize(){
  const r = mapEl.getBoundingClientRect();
  return { w: Math.max(1, r.width), h: Math.max(1, r.height) };
}

/* object-fit: contain + scale の「実表示画像矩形」を推定 */
function getDisplayedImageRect(scale){
  const { w, h } = getMapSize();

  // 画像未ロード時の保険
  const nw = mapImg.naturalWidth  || 1;
  const nh = mapImg.naturalHeight || 1;

  const imgAspect = nw / nh;
  const boxAspect = w / h;

  let iw0, ih0;
  if (imgAspect > boxAspect) {
    iw0 = w;
    ih0 = w / imgAspect;
  } else {
    ih0 = h;
    iw0 = h * imgAspect;
  }

  const iw = iw0 * scale;
  const ih = ih0 * scale;
  const ox = (w - iw) / 2;
  const oy = (h - ih) / 2;

  return { ox, oy, iw, ih };
}

function buildAnchorNorm(data){
  const baseW = Number(data.baseW ?? data.calibW ?? 420);
  const baseH = Number(data.baseH ?? data.calibH ?? 420);

  return data.anchors.map(a => ({
    // 新：画像基準 inx/iny（推奨）
    inx: (a.inx != null) ? Number(a.inx) : null,
    iny: (a.iny != null) ? Number(a.iny) : null,

    // 旧：枠基準 nx/ny
    nx: (a.nx != null) ? Number(a.nx) : null,
    ny: (a.ny != null) ? Number(a.ny) : null,

    // さらに旧：px
    x:  (a.x  != null) ? Number(a.x)  : null,
    y:  (a.y  != null) ? Number(a.y)  : null,

    baseW, baseH,

    lat: Number(a.lat),
    lon: Number(a.lon),
    label: a.label ?? ""
  }));
}

function anchorToPx(a){
  const { w, h } = getMapSize();

  // 1) 新：画像基準 inx/iny
  if (a.inx != null && a.iny != null) {
    const scale = Number(currentField?.defaultImgScale ?? 1.0);
    const rect = getDisplayedImageRect(scale);
    return {
      x: rect.ox + a.inx * rect.iw,
      y: rect.oy + a.iny * rect.ih
    };
  }

  // 2) 旧：枠基準 nx/ny
  if (a.nx != null && a.ny != null) {
    return { x: a.nx * w, y: a.ny * h };
  }

  // 3) さらに旧：px + baseW/baseH
  const nx = (a.x != null) ? (a.x / a.baseW) : 0.5;
  const ny = (a.y != null) ? (a.y / a.baseH) : 0.5;
  return { x: nx * w, y: ny * h };
}

async function openFieldByFile(file) {
  try {
    const res = await fetch(`fields/${file}`, { cache: "no-store" });
    if (!res.ok) throw new Error("field json not found");
    const data = await res.json();

    if (!data || !Array.isArray(data.anchors) || data.anchors.length !== 4) {
      alert("フィールドデータが不正（anchorsが4点必要）");
      return;
    }

    currentField = data;
    document.getElementById("fieldTitle").textContent = data.name || data.id || "Field";

    // 画像：端末差でズレないよう「fit + scale」
    document.documentElement.style.setProperty("--imgScale", String(data.defaultImgScale ?? 1.0));

    // 表示リセット
    gpsEl.textContent = "--.------:--.------";
    meDot.style.display = "none";
    mapWarning.style.display = "none";

    // ★重要：画像がロードされて naturalWidth/Height が確定してから transform確定
    mapImg.onload = () => {
      try{
        anchorNorm = buildAnchorNorm(data);
        prepareTransform(anchorNorm);   // ← ここで1回だけ
        buildGridLabels(30);
      }catch(e){
        console.error(e);
      }
    };
    mapImg.src = data.image;

    show("field");
    requestAnimationFrame(() => buildGridLabels(30));

  } catch (e) {
    alert("フィールド読み込み失敗。fieldsフォルダとjsonを確認して。");
    console.error(e);
  }
}

/* ==================================================
  4点GPS → マップXY（ホモグラフィ）
================================================== */
const R = 6378137;

function latLonToLocalMeters(lat, lon) {
  const x = (lon - lon0) * Math.PI/180 * cosLat0 * R;
  const y = (lat - lat0) * Math.PI/180 * R;
  return { X: x, Y: y };
}

function solveLinear(A, b) {
  const n = b.length;
  const M = A.map((row, i) => row.concat([b[i]]));

  for (let col = 0; col < n; col++) {
    let pivot = col;
    for (let r = col + 1; r < n; r++) {
      if (Math.abs(M[r][col]) > Math.abs(M[pivot][col])) pivot = r;
    }
    [M[col], M[pivot]] = [M[pivot], M[col]];

    const div = M[col][col];
    if (Math.abs(div) < 1e-12) throw new Error("singular");

    for (let c = col; c <= n; c++) M[col][c] /= div;

    for (let r = 0; r < n; r++) {
      if (r === col) continue;
      const f = M[r][col];
      for (let c = col; c <= n; c++) M[r][c] -= f * M[col][c];
    }
  }
  return M.map(row => row[n]);
}

function computeHomography(anchors) {
  const A = [];
  const b = [];

  const anchorsPx = anchors.map(anchorToPx);

  for (let i = 0; i < 4; i++) {
    const p = anchors[i];
    const { x, y } = anchorsPx[i];
    const { X, Y } = latLonToLocalMeters(p.lat, p.lon);

    A.push([X, Y, 1, 0, 0, 0, -x*X, -x*Y]); b.push(x);
    A.push([0, 0, 0, X, Y, 1, -y*X, -y*Y]); b.push(y);
  }
  return solveLinear(A, b);
}

function prepareTransform(anchors) {
  lat0 = anchors.reduce((s,a)=>s+a.lat,0)/4;
  lon0 = anchors.reduce((s,a)=>s+a.lon,0)/4;
  cosLat0 = Math.cos(lat0 * Math.PI/180);
  H = computeHomography(anchors);
}

/* resizeでmapサイズが変わったらHを作り直す（超重要） */
function rebuildTransformIfReady(){
  if (!currentField || !anchorNorm) return;
  try {
    prepareTransform(anchorNorm);
  } catch (e) {
    console.error(e);
  }
}

function gpsToMapXY(lat, lon) {
  const { X, Y } = latLonToLocalMeters(lat, lon);
  const [h11,h12,h13,h21,h22,h23,h31,h32] = H;

  const denom = h31*X + h32*Y + 1;
  const x = (h11*X + h12*Y + h13) / denom;
  const y = (h21*X + h22*Y + h23) / denom;
  return { x, y };
}

/* ==================================================
  グリッドラベル
================================================== */
function buildGridLabels(step = 30) {
  const box = document.getElementById("gridLabels");
  if (!box) return;
  box.innerHTML = "";

  const { w, h } = getMapSize();
  const cols = Math.floor(w / step);
  const rows = Math.floor(h / step);

  for (let col = 1; col < cols; col++) {
    const d = document.createElement("div");
    d.className = "grid-x";
    d.style.left = `${col * step + step / 2}px`;
    d.style.top  = `${step * 0.25}px`;
    const idx = col - 1;
    d.textContent = String.fromCharCode(65 + idx);
    box.appendChild(d);
  }

  for (let row = 1; row < rows; row++) {
    const d = document.createElement("div");
    d.className = "grid-y";
    d.style.left = `${step * 0.25}px`;
    d.style.top  = `${row * step + step / 2}px`;
    d.textContent = row;
    box.appendChild(d);
  }
}

/* ==================================================
  GPS SCAN
================================================== */
function scan() {
  if (!currentField || !H) {
    gpsEl.textContent = "先にフィールド選択";
    return;
  }
  if (!navigator.geolocation) {
    gpsEl.textContent = "GPS: 非対応端末";
    return;
  }

  gpsEl.textContent = "取得中...";

  navigator.geolocation.getCurrentPosition(
    (pos) => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      gpsEl.textContent = `${lat.toFixed(6)}:${lon.toFixed(6)}`;

      const { x, y } = gpsToMapXY(lat, lon);
      const { w, h } = getMapSize();

      const isOutOfField = (x < 0 || y < 0 || x > w || y > h);

      if (isOutOfField) {
        meDot.style.display = "none";
        mapWarning.style.display = "flex";
        return;
      }

      mapWarning.style.display = "none";
      meDot.style.left = `${x}px`;
      meDot.style.top  = `${y}px`;
      meDot.style.display = "block";
    },
    () => {
      gpsEl.textContent = "GPS: 取得失敗";
    },
    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
  );
}

/* ==================================================
  リサイズ追従（iPhoneのアドレスバー出入りも含む）
================================================== */
const ro = new ResizeObserver(() => {
  buildGridLabels(30);
  rebuildTransformIfReady();
});
ro.observe(mapEl);

/* ==================================================
  省電力 & 復帰時のズレ防止
================================================== */
function recalcRemainingIfRunning(){
  if(running && endTimeMs != null){
    remainingMs = Math.max(0, endTimeMs - Date.now());
    if(remainingMs === 0){
      running = false;
      zeroMode = true;
      endTimeMs = null;
      setStartStopIcon(false);
      stopTicking();
    }
    updateDisplay(remainingMs);
  }
}

document.addEventListener("visibilitychange", () => {
  recalcRemainingIfRunning();
  persistTimerState();
  if(!document.hidden && running){
    startTicking();
  }
});

window.addEventListener("pagehide", () => {
  recalcRemainingIfRunning();
  persistTimerState();
}, { capture: true });

window.addEventListener("beforeunload", () => {
  recalcRemainingIfRunning();
  persistTimerState();
}, { capture: true });

/* ==================================================
  起動
================================================== */
restoreTimerState();
loadFieldList();
setStartStopIcon(running);

if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js");
}
</script>